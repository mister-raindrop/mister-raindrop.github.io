---
layout: post
title: "Rant about Javascript taking my time and #100DaysOfCode ||  Day #1 Updates"
excerpt: "My #100DaysOfCode starts today. I'm breaking a few rules of the original challenge, but I'm learning what I wanted to from a long time. A bit of ranting inside about Javascript."
share: true
comments: true
tags: [haskell, python, algorithm, #100daysofcode]
author: krishna_gogoi
categories: programming
---


## Introduction

Hello blog, we meet again. Last time I blogged, it was in December, 2015.
Mostly because I've been both busy and lazy, and I did try my best, but then
I kept on procrastinating about it and here we are.

We're here today because we are doing [#100DaysOfCode](https://twitter.com/hashtag/100DaysOfCode?src=hash).
If you don't know about it, you ought to go read [THIS](https://medium.freecodecamp.com/join-the-100daysofcode-556ddb4579e4#.hv2xfvb67) article.

I've started  few days late, mostly because weekdays have been pretty busy and I wanted to start
on the weekend after sorting out a few things. It also gave me a few days of time to scout out
on twitter and other places what everyone else is doing for their **#100DaysOfCode**.

Things I've noticed is that [Free Code Camp](http://freecodecamp.com) is very tightly knit into
a lot of people's **#100DaysOfCode**. And a lot of these projects are about web technologies,
primarily Javascript and all the frameworks that are out there. It makes sense given how ubiquitous
Javascript has become on the web and I really like the projects on FCC and how there's like the
checklist of features you need to complete. So for something like this, I'd be hard pressed to
suggest something else other than to just work on your own pet peeves. But if you don't have one
or haven't planned one or don't wanna spend too much time and committment on it, I think FCC is a
really good alternative. In fact, the person who started **#100DaysOfCode** is following a roadmap
on FCC as well!

## My Saturation with JS and why I won't be including it in my #100DaysOfCode

Initially, I thought of going for one of the projects in FCC as well since everyone else is. And
honestly, that wouldn't have been too bad of a choice. I mean, most, if not all, of my client work
is based on Javascript and related stuff. Recently all I've done on that side of my life is Meteor
and React. Clients love those live updating visualizations. So dedicating my after-work time to some
more Javascript would probably help me out a lot.

But I wanted to take things a different direction. Lately I've been feeling a bit saturated with
Javascript and everything about it that's out there. Don't get me wrong, I love the technologies it's
pregnant with and has given birth to in the past few years, and if it wasn't for it's broken features
and duct tapes everywhere, I'd say JS is perfect (I'm kidding, it's not). I love Node, I love D3, I love
Meteor and React, they are interesting, amazing and put more food on my table. But I work with them
literally everyday. And that does lead to a bit of saturation over time, especially when you keep pushing
a lot of other things that you've always wanted to do to the side so that you can keep up client demands
about making their website responsive in IE4.

It's absolutely fine if JS is the language love of your programming life and you want to get better at it.
In fact, I'd be lying if I said I wouldn't improve my JS chops by dedicating time for it in the next 100 days.
But working with it everyday has made me kinda saturated about it. Around 6 days a week, I work with JS. A lot
of us have our own #100DaysOfCode at work everyday. With new web technologies coming in everyday, you have to
be very committed to stay updated and keep learning more JS-related stuff to stay ahead. I mean, couple of years
ago Node.js was considered not ready for production, and look where we are now. ES6 is right there, knocking on
everyone's doors. Angular actually feels old and Meteor actually has stable releases. That's exactly what I've been
doing lately: learning more frameworks, learning more ES6, learning more libraries, digging out books on JS
that'll make me understand what the frick the current value of **this** is, reading about JS design patterns
and occasionally attempt at defending the language's shortcomings. It sounds great if you plan on just being
a JS developer and working on web technologies, it really is. But if you have other interests in programming,
say learning a functional language, learning more algorithms, trying out system programming, or literally
just any programming interest outside of web and JS, it becomes extremely hard to keep up with everything AND
do your client work AND learning X new framework AND spending time doing other stuff like playing Overwatch and
Dota2, taking your dog out for a walk and so on.


And if you have a reading or learning list that doesn't include JS as its core, chances are you've made very little progress on it.
The last time I added something to my things-to-learn list is like on January, 2015. I wanted to properly learn
the amazing things inside Haskell's [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia).

Scrolling up on it, I wanted to read [Linux Device Drivers](https://lwn.net/Kernel/LDD3/), learn the internals
of device drivers on Linux, and somewhere in the back of my peasant programmer mind, I wanted to be good
at it and contribute back to the piece of software that I use literally everyday. I wanted to complete
reading [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/) and
[Real World Haskell](http://book.realworldhaskell.org/). [C Interfaces and Implementations](https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413)
has been on my reading list since 2014. Heck, Javascript books like [The Web Game Developer's Cookbook](https://www.amazon.com/Web-Game-Developers-Cookbook-JavaScript/dp/0321898389)
have been there for a long time.

Point I'm trying to make is that I've given far too much time to JS, in order to earn more, in order to
be able to stand up on today's fast-paced world, in order to live up to the expectations of today's
clients and startup founders who want bleeding edge technology to power their applications, written preferably
by a programming wizard/ninja/rockstar. Don't get me wrong here, I do love Javascript and everything it lets us
modern developers do. But I also love other things too, I love functional programming languages, I love clever
and efficient algorithms, I love reading Burrito-spacesuit monad tutorials, I love HTML5+JS games. And now that
I look back, I realize that I haven't done anything even remotely related to these things in the past year.


### So, what does that have to do with #100DaysOfCode?

Since #100DaysOfCode promotes the idea of creating a habit out of coding everyday, I'm taking it one step ahead
to get into the habit of learning and coding things I love that are !JS. For the next 100 days, I will dedicate
at least an hour everyday (if not more) to coding and learning a few of the things that I've wanted to do for a
long time but haven't been able to make time for. I will be breaking one of the rules in #100DaysOfCode, but I'll
describe that in detail later.

I wanna write a blog post, around 100 days from now, and see for myself if I really have been able to make time
out for staying in touch with all these other things, and how much, if at all, I've improved. Of course, during
all of this, I'll still be working, so it's not like I'm ditching JS for good; I'm just making time for other stuff
like Haskell.

This also means I'll stop my Overwatch and Dota2 doses. They nerfed McCree and Earth Spirit anyway.


## Goals for my #100DaysOfCode

So I have a bunch of goals I've set up in my mind for the next 100 days. I'm blogging them down so that I stick to
the plan. My primary goals will be to:
1. Re-learn Haskell properly and get at least to a decent level where I can start reading other people's code
and make small programs myself.
2. Revise algorithms, data structures and their implementations, and quite possibly learn new ones that I avoided
before.


I want to keep my focus mostly on the above two goals because I feel like they've been nagging me at the back of my
head for quite some time. Haskell has always been there, I've attempted it before and I did make progress, I love
Haskell. But I've been out of shape for a long time, so I'm going to empty myself and attempt this as if I'm starting
now. I wanna learn from the beginning and this time, do it with a proper structure.

For that purpose, I even bought a copy of [Haskell from First Principles](http://haskellbook.com). It costed me $60,
more than my copy of Overwatch ($40), and I have huge expectations from the book. All the reviews so far have been
amazing about the book and I like the content covered in it. It's quite thick at around 1.2k pages, so I'm expecting
to do a lot of reading.

And this is where my #100DaysOfCode will deviate a bit. The official rules state that time towards doing tutorials,
reading, etc. will not be counted, and that code written should be for the actual project, that solves some real-world
problem. As I am right now, I can't code anything even close to the real-world with Haskell. So projects are just out
of the question. With JS, this would be less of a problem as FCC has roadmaps for beginning JS programmers as well.
Also, JS is much more easier to get started with than Haskell.

So, I'll be doing a few things to remedy this problem. Firstly, I'll complete any and all exercises in the book chapters.
These sort of will be my 'projects', so to speak, as doing an actual project in Haskell will require me to learn
at least IO and a bunch of (Maybe) monadic stuff (see what I did there, omg). I don't really wanna skip on learning
things the right way for the sake of keeping up with the challenge rules. So, exercises, I shall not skip.

Secondly, once I feel I have the bare basics of the language down, which I'm guessing will be the first 5-6 chapters,
I'll start solving problems in [CodeWars](http://codewars.com). They have lots of dedicated problems for Haskell and
I feel like they'll help bolster any concepts I learn in the book. Also, I think they have a feature for looking at
other people's code after you submit yours, so I believe I'll pick up a thing or two by checking out how other people
solve the same problem in the same language. This again, partially follows the rule in the challenge. I will be writing
code outside of reading, but it won't exactly be code for a project or such. I think the rules should add an exception
in the FAQ for situations like this. I mean, what about Brainfuck? I kid.

Thirdly, this is also where my second goal comes in. Algorithms, data structures and most importantly, their implementations.
I'll be revising and learning algorithms and data structures again, because being a JS developer for the majority
of the year lately has made me forget some of these crucial concepts. So I wanna re-visit them, learn what I can, and
implement them in Python. Oh Python, I've missed you so much. So if I ever have a day when I've mostly just read the
Haskell book, I'll at the very least try to spend some time implementing an algorithm/data structure in Python, making
sure that I write some code and think about something everyday. After all, the whole point of this challenge is to make
a habit.

Lastly, I will update the blog everyday with my progress, post what I've learnt, share what I've learnt in a mini tutorial
format and so on. If not everyday, I wanna do this at least every alternate day. This is sort of compensation for the fact
that I don't have any real projects to follow upon such as the roadmaps on FCC. I'll share any code snippets I've written
or spent time on, on the blog. Consider the blog my journal for the next 100 days. If I overcame something difficult, I'll
write about that, if I just optimized a method, I'll write how. I will also make sure to NOT play Dota2 or Overwatch before
I write that daily blog post.


So, the book I want to read for the second challenge is [Introduction to Algorithms: A Creative Approach](https://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372) by Udi Manber.
I know, I know, it's not the one by CLRS. But I've heard good things about this book as well, and I like how the book
is structured, not as a catalog of algorithms, but more like it has sections of algorithms that are devised using
a certain technique, like say Induction, or Reduction, Geometric algorithms and so on. So I feel like learning from this
book would not only give me better understanding of algorithms but how to approach problems as well. I still will keep a copy
of CLRS nearby though, for reference and because it's time-tested. Let's see how the other book goes. I'm feeling it will
be a bit mathematical in nature so I'll probably take my time working through it slowly.


Last book that I'll be occasionally reading is [Expert C Programming: Deep C Secrets](https://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298) by Peter van der Linden.
I remember what an absolute joy it was to read this book. I wanna read it again not only to experience that again but
I feel like revising the trickier bits of C in an entertaining way would be helpful. This won't be on top of my priorities
but I'll make time for it whenever I can, most definitely on weekends.


## Further Plans

If everything goes well and I haven't thrown the towel in by 30 days, I think I should have enough Haskell knowledge to
work on something small but well-guided in Haskell. I plan on studying [Write Yourself a Brainfuck in an hour](https://github.com/quchen/articles/blob/master/write_yourself_a_brainfuck.md),
followed by [Write Yourself a Scheme in 48 Hours](https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours).
So halfway through the challenge or so, I should have something decent to pass off as a project.

I also WANT to read [Purely Functional Data Structures](https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504) by Chris Okasaki.
However, I believe I won't have the needed experience/maturity in Haskell to grasp the book. So I'm not expecting myself
to be able to finish this book in the next 100 days, however I'll give it a try. Part of the reason I want to do it during
this period is because then I can start to blend Haskell and my other goal of algorithms and data structures together very nicely.
Chances of this happening is pretty low, but let's see where I end up.

If I find other great books or resources or projects to finish as I continue, I'll add them as necessary into my plan. I'll be posting
updates every day or every two days, so anyone following along for whatever reason could consider them as well.

That's basically it for my personal rant and roadmap. I hope I'm able to stick through with the challenge for the next 100 days
and come out of it as someone who's learnt a bit of Haskell. To everyone else who's doing the challenge, good luck. I'll be updating
my progress on my newly-made twitter account as well: [@NotEnoughCringe](https://twitter.com/NotEnoughCringe). Good luck to everyone
on this journey!



--------------



# Updates for Day 1

I wrote the blog post same day as Day 1 of my challenge. So here's my update for Day 1. I won't make it too long as I'm really
tired and this post is already too long.

I read the first three chapters of Haskell from First Principles, which basically covers some very basic Lambda Calculus,
basic Haskell syntax, interacting with the REPL, functions, infix operators, strings and a bunch of standard list functions
(head, tail, take, drop, etc). So far the exercises have been very simple and a breeze mostly. I also like the book and how
it is paced. It assumes very little programming knowledge so I'm guessing someone who hasn't yet learned any language could
actually try to follow it, that'd be something interesting to see.

I also reviewed a bit of induction from the book by Udi Manber. I've been kinda rusty so I decided to solve a few induction
problems from an old mathmatics textbook. The book in itself is pretty mathematical so far, although I've only read upto the
second subsection of the second chapter. It's hard but I like it.

For my daily coding part, I managed to solve the first CodeWars challenge in Haskell (Boiled Eggs). I felt pretty good till
I saw the other clever solutions. I mean it was an easy solution already, but some solutions are so chic and overkill, I
absolutely love them. I plan on reviewing solutions like these later when I learn more.

I also implemented the graph data structure in Python. Previously, I used to do it by creating classes for Vertex and Graph
and so on. I read an article somewhere today about how it can be implemented using Python's native dictionaries. I got the
basics working out today like membership checks and so on. Basically, store graph information as a dictionary of sets. Each
key in this dictionary represents a vertex. The value of this key is a set of all the vertices to which it has an edge. Something
like this:

{% highlight python %}
graph_G = {"a": {"b", "c", "d"},
           "b": {"a", "c"},
           "c": {"a", "d", "b"},
		   "d": {"c", "a"}}
{% endhighlight %}

To check if 'a' has an edge to 'd', you can do:
`'d' in graph_G['a'] # True`

To add an edge from 'b' to 'd':
`graph_G['b'].add('d')`

I quite like this way of representing graphs as it uses methods that are available natively in Python, so it's very
efficient. I'm also writing a Graph class out of this technique that I'll be later using across my algorithm lessons.
I couldn't complete it today but it should be done in a day or two. I'm trying to cramp as many methods I can and trying
to figure out better ways of passing information to it. Been out of practice with Python for a while, but I feel like it's
coming back now.

I expect the next 10 days to go similarly, more on reading and learning and doing Haskell exercises peppered with Python implementations
of algorithms and data structures.

I also read a bit of Expert C Programming: Deep C Secrets. It's just as delightful as ever. Read up a bit on C's history, and how it
emerged from the aftermath of the Multics project, PDP-7 implementation based on BCPL, evolving into B and then finally into C. I feel like
I can keep on reading this book without getting bored so I switched back to Haskell before getting distracted. I plan on continuing to
use it as a story book of sorts, sprinkled with C tidbits everywhere.

Day 1/100 completed. Cheers to everyone else on their 100 day track!
